from django.http import HttpResponse
from django.template import loader
import smtplib
import dns.resolver
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.utils import formatdate
from email.utils import parsedate_to_datetime
from smtplib import SMTPNotSupportedError
import paramiko
from email.utils import make_msgid
import random
import string
import logging
import datetime
import traceback
import dkim
import os

logger = logging.getLogger('spf_referral_vulnerability_checker')
cache = {}


def clear_cache(request):
    # minutes = request.POST['mins']
    for to in cache:
        dt = parsedate_to_datetime(cache[to]['Date'])
        diff = datetime.datetime.now(datetime.timezone.utc) - dt
        if diff.seconds / 60 > 86400:
            cache.pop(to)


def home(request):
    # logger.debug('this is a debug message!')
    context = {}
    email_address = request.POST.get('email')
    if email_address in cache:
        context = {'cache_pop': True}
        cache.pop(email_address)
    template = loader.get_template('../templates/spf_referral_vulnerability_check/index.html')
    return HttpResponse(template.render(context, request))


def contact(request):
    template = loader.get_template('../templates/spf_referral_vulnerability_check/contact.html')
    context = {}
    return HttpResponse(template.render(context, request))


def extract_mx(to):
    recd = to.split('@')[1]
    mxs = []
    for x in dns.resolver.resolve(recd, 'MX'):
        mxs.append(x.to_text().split()[1])
    return mxs


def get_message(submitter, to):
    message = MIMEMultipart("alternative")
    message["Subject"] = "SPF Referral Vulnerability Test"
    message["From"] = submitter
    message["To"] = to
    message['Message-ID'] = make_msgid()
    message["Date"] = formatdate(localtime=True)

    # Create the plain-text and HTML version of your message
    text = """\
Hi,
This is a test email sent from https://spf.net-measurement.net/home referral vulnerability checker website with your permission.
If you did not agree to receive this message, please send us a reply back to this email.

Thanks."""
    html = """\
<html>
  <body>
    <p>Hi,<br>
    This is a test email sent from https://spf.net-measurement.net/home referral vulnerability checker website with your permission.<br>
    If you did not agree to receive this message, please send us a reply back to this email.<br><br>Thanks.
    </p>
  </body>
</html>"""

    # Turn these into plain/html MIMEText objects
    part1 = MIMEText(text, "plain")
    part2 = MIMEText(html, "html")

    # Add HTML/plain-text parts to MIMEMultipart message
    # The email client will try to render the last part first
    message.attach(part1)
    message.attach(part2)
    return message


def send_mail(message, qn, mx, to):
    submitter = message["From"]

    # not doing with one specific subdomain is because of parallel connection
    # 1. transfer "spf-referral" file content to a new file called qn
    # 2. delete "spf-referral" file
    addresses, errors = [], []
    try:
        try:
            a = dns.resolver.resolve(mx, 'A')
            for ip in a:
                addresses.append(ip.to_text())
        except Exception as e:
            pass
        try:
            aaaa = dns.resolver.resolve(mx, 'AAAA')
            for ip in aaaa:
                addresses.append(ip.to_text())
        except Exception as e:
            pass
        logger.debug(",".join(addresses))
        for ip in addresses:
            try:
                with smtplib.SMTP(ip, 25, timeout=10) as srvr:
                    srvr.set_debuglevel(3)
                    srvr.ehlo(submitter.split('@')[1])  # should i pass customized msg to helo in submitter.split('@')[1]
                    try:
                        srvr.starttls()
                    except SMTPNotSupportedError as e:
                        pass
                    except Exception as e:
                        pass
                    srvr.helo(submitter.split('@')[1])
                    srvr.sendmail(submitter, to, message.as_string())
                    logger.debug("Successfully sent email from", submitter, "to", to)
                    success = open('/var/www/html/spf_referral_vulnerability_check/success/' + qn, 'a')
                    success.write(qn + ' ' + to + ' ' + mx + '\n')
                    success.close()
                    if message["To"] in cache:
                        cache.pop(message["To"])
                    return True
            except Exception as e:
                logger.debug(ip + " " + str(e))
                errors.append(ip + " " + str(e))
            logger.debug(" ".join(errors))
    except Exception as e:
        errors.append("main exception " + str(e))
        failed = open('/var/www/html/spf_referral_vulnerability_check/failed/' + qn, 'a')
        failed.write(qn + ' ' + to + ' ' + mx + ' ' + " ".join(errors) + '\n')
        failed.close()
        x = check_whether_spf_query_is_made(qn)
        if x:
            logger.debug('In short: from: ' + submitter + ' mx: ' + mx + ' to: ' + to + ' id: ' + qn + ' Exception: ' + \
                         " ".join(errors) + ' but will return true bcs SPF query has been made')
        else:
            logger.debug('In short: from: ' + submitter + ' mx: ' + mx + ' to: ' + to + ' id: ' + qn + ' Exception: ' + \
                         " ".join(errors))
        logger.debug(traceback.format_exc())
        return x


def check_whether_spf_query_is_made(qn):
    file_path = "/data/spf-redirection/spf-website/" + qn
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key = paramiko.RSAKey.from_private_key_file('/var/www/html/aws_rsa')
    ssh_client.connect('23.21.78.86', username='ubuntu', pkey=key)

    with ssh_client.open_sftp() as sftp_client:
        try:
            sftp_client.stat(file_path)
            # file exists
            return True
        except Exception as e:
            # file does not exist
            return False


def empty_file_if_exists(qn):
    file_path = "/data/spf-redirection/spf-website/" + qn
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key = paramiko.RSAKey.from_private_key_file('/var/www/html/aws_rsa')
    ssh_client.connect('23.21.78.86', username='ubuntu', pkey=key)

    with ssh_client.open_sftp() as sftp_client:
        try:
            sftp_client.stat(file_path)
            # file exists
            sftp_client.remove(file_path)
        except Exception as e:
            # file does not exist
            pass


def getCode(length=7, char=string.digits + string.ascii_lowercase):
    return ''.join(random.choice(char) for x in range(length))


def collect_queries(qn):
    # connect to 23.21.78.86
    file_path = "/data/spf-redirection/spf-website/" + qn
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key = paramiko.RSAKey.from_private_key_file('/var/www/html/aws_rsa')
    ssh_client.connect('23.21.78.86', username='ubuntu', pkey=key)

    lines = []
    with ssh_client.open_sftp() as sftp_client:
        try:
            sftp_client.stat(file_path)
            # file exists
        except Exception as e:
            # file does not exist
            return "No File"
        with sftp_client.open(file_path) as remote_file:
            # prev_ip = None
            for line in remote_file:
                ts1, ts2, ip, qn, qt, rcode, tc, rd, cd = line.strip().split(' ')
                # ts = ts1 + '-' + ts2
                # ha5h = qn.split('.')[-1]
                # if qn == ha5h and prev_ip != ip:
                #     prev_ip = ip
                lines.append(ts1 + ' ' + ts2 + ' ' + ip + ' ' + qn + '.cjone.app' + ' ' +
                             qt + ' ' + rcode)
                # prev_ip = ip

        # Upload
        # sftp_client.remove(file_path)

        # process line
        return lines


def add_dkim_sign(message):
    # DKIM Private Key for example.com RSA-2048bit
    private_key = open(os.path.join('/var/www/html/', 'mail.private')).read()

    # Specify headers in "byte" form
    headers = [b'from', b'to', b'subject', b'message-id']

    # Generate message signature
    sig = dkim.sign(message.as_bytes(), b'mail', b'' + "cjone.app".encode(), private_key.encode(),
                    include_headers=headers)
    sig = sig.decode()

    # Add the DKIM-Signature
    message['DKIM-Signature'] = sig[len("DKIM-Signature: "):]
    return message


def summary(request):
    context = {'lookups': 0,
               'queries': '',
               'email_sent': 'no',
               'permission': 'no',
               'retry': 'no',
               'retry_diff': 0,
               'email': None}
    template = loader.get_template('../templates/spf_referral_vulnerability_check/summary.html')
    try:
        # extract data
        email_address = request.POST.get('email', None)
        context['email'] = email_address
        if not email_address:
            return HttpResponse(template.render(context, request))
        recv_email = request.POST.get('recv-email', 'off')
        if recv_email != 'on':
            return HttpResponse(template.render(context, request))
        else:
            context['permission'] = 'yes'
        # send an email
        if email_address in cache:
            context['retry'] = 'yes'
            message = cache.get(email_address)
            qn = message["From"].split('@')[1].split('.')[0]
            dt = parsedate_to_datetime(cache[email_address]['Date'])
            diff = datetime.datetime.now(datetime.timezone.utc) - dt
            context['retry_diff'] = diff.seconds // 60
            if diff.seconds / 60 <= 15:
                success = False
                return HttpResponse(template.render(context, request))
        else:
            qn = getCode()
            empty_file_if_exists(qn)
            submitter = "ubuntu@" + qn + ".cjone.app"
            message = get_message(submitter, email_address)
            add_dkim_sign(message)
        mxs = extract_mx(email_address)
        for ind, mx in enumerate(mxs):
            logger.debug(mx, email_address)
            if email_address in cache:
                success = send_mail(cache[email_address], qn, mx, email_address)
            else:
                success = send_mail(message, qn, mx, email_address)
            if success:
                queries = collect_queries(qn)
                if queries == "No File":
                    context['lookups'] = 0
                    context['queries'] = ""
                    context['email_sent'] = 'yes'
                else:
                    context['lookups'] = len(queries)
                    context['queries'] = "\n".join(queries)
                    context['email_sent'] = 'yes'
                break
            else:
                # cache[email_address] = message
                pass
        if context["email_sent"] != "yes":
            # We could not immediately deliver our test mail. This can happen if your mail-server uses greylisting or is temporarily unavailable. Click here to be able to retry this test later. We will then save your email address until you retry this test after at least 15min, or until a day has passed, whichever comes first.
            cache[email_address] = message
        return HttpResponse(template.render(context, request))
    except Exception as e:
        # Handle no such file error
        logger.debug('summary: ' + str(e))
        logger.debug(traceback.format_exc())
        return HttpResponse(template.render(context, request))