from django.http import HttpResponse
from django.template import loader
import smtplib
import dns.resolver
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from smtplib import SMTPNotSupportedError
import paramiko
from email.utils import make_msgid


def home(request):
    template = loader.get_template('../templates/spf_referral_vulnerability_check/index.html')
    context = {}
    return HttpResponse(template.render(context, request))


def contact(request):
    template = loader.get_template('../templates/spf_referral_vulnerability_check/contact.html')
    context = {}
    return HttpResponse(template.render(context, request))


def extract_mx(to):
    recd = to.split('@')[1]
    mxs = []
    for x in dns.resolver.resolve(recd, 'MX'):
        mxs.append(x.to_text().split()[1])
    return mxs


def send_mail(mx, to):
    submitter = "ubuntu@spf-referral-vuln-checker.cjone.app"

    message = MIMEMultipart("alternative")
    message["Subject"] = "SPF Referral Vulnerability Test"
    message["From"] = submitter
    message["To"] = to
    message['Message-ID'] = make_msgid()

    # Create the plain-text and HTML version of your message
    text = """\
Hi,
This is a test email sent from https://spf.net-measurement.net/home referral vulnerability checker website with your permission.
If you did not agree to receive this message, please send us a reply back to this email.

Thanks."""
    html = """\
<html>
  <body>
    <p>Hi,<br>
    This is a test email sent from https://spf.net-measurement.net/home referral vulnerability checker website with your permission.<br>
    If you did not agree to receive this message, please send us a reply back to this email.<br><br>Thanks.
    </p>
  </body>
</html>"""

    # Turn these into plain/html MIMEText objects
    part1 = MIMEText(text, "plain")
    part2 = MIMEText(html, "html")

    # Add HTML/plain-text parts to MIMEMultipart message
    # The email client will try to render the last part first
    message.attach(part1)
    message.attach(part2)

    try:
        with smtplib.SMTP(mx, 25, timeout=10) as srvr:
            srvr.set_debuglevel(3)
            srvr.ehlo(submitter.split('@')[1])  # should i pass customized msg to helo in submitter.split('@')[1]
            try:
                srvr.starttls()
            except SMTPNotSupportedError as e:
                pass
            except Exception as e:
                pass
            srvr.helo(submitter.split('@')[1])
            srvr.sendmail(submitter, to, message.as_string())
            print("Successfully sent email from", submitter, "to", to)
            # success = open('success/success_' + , 'a')
            # success.write(receiver + ' ' + mx + '\n')
            # success.close()
            return True
    except Exception as e:
        # failed = open('failed/failed_' + str(pid), 'a')
        # failed.write(to + '\t' + mx + '\t' + str(e) + '\n')
        # failed.close()
        print(e)
        import traceback
        traceback.print_exc()
        return False


def collect_queries():
    # connect to 23.21.78.86
    qn = "spf-referral-vuln-checker"
    file_path = "/data/spf-redirection/spf/" + qn
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    key = paramiko.RSAKey.from_private_key_file('/root/aws_rsa')
    ssh_client.connect('23.21.78.86', username='ubuntu', pkey=key)

    lines = []
    with ssh_client.open_sftp() as sftp_client:
        with sftp_client.open(file_path) as remote_file:
            prev_ip = None
            for line in remote_file:
                ts1, ts2, ip, qn, qt, rcode, tc, rd, cd = line.strip().split(' ')
                ts = ts1 + '-' + ts2
                ha5h = qn.split('.')[-1]
                if qn == ha5h and prev_ip != ip:
                    prev_ip = ip
                lines.append(ts1 + ' ' + ts2 + ' ' + ip + ' ' + qn + '.cjone.app' + ' ' +
                             qt + ' ' + rcode)
                prev_ip = ip

        # Upload
        sftp_client.remove(file_path)

        # process line
        return lines


def summary(request):
    context = {'lookups': 10, 'queries': '', 'email-sent?': 'no', 'permission': 'no'}
    template = loader.get_template('../templates/spf_referral_vulnerability_check/summary.html')
    try:
        # extract data
        email_address = request.POST['email']
        recv_email = request.POST['recv-email']
        if recv_email != 'on':
            return HttpResponse(template.render(context, request))
        else:
            context['permission'] = 'yes'
        # send an email
        mxs = extract_mx(email_address)
        for ind, mx in enumerate(mxs):
            print(mx, email_address)
            success = send_mail(mx[:-1], email_address)
            queries = collect_queries()
            context['lookups'] = len(queries)
            context['queries'] = "\n".join(queries)
            if success:
                context['email_sent'] = 'yes'
                break
            if ind == 0:  # TODO: remove this if block
                break
        # calculate # of queries and other meta data
        # serve it in index.html
        return HttpResponse(template.render(context, request))
    except Exception as e:
        return HttpResponse(template.render(context, request))